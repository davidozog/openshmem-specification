\color{ForestGreen}

All \openshmem RMA, AMO, and memory ordering routines are
performed on a communication context.  The communication context defines an
independent ordering and completion environment, allowing users to manage the
overlap of communication with computation and also to manage communication
operations performed by separate threads within a multithreaded \ac{PE}.
\textcolor{red}{(Manju suggests moving the following to a Note or prefacing it with a
``\textit{Rationale}":) For example, in single-threaded environments, contexts can
be used to pipeline communication and computation.  In multithreaded
environments, contexts can additionally provide thread isolation, eliminating
overheads resulting from thread interference within the communication
subsystem.}

Context handles are of type \CTYPE{shmem\_ctx\_t} and are valid for
language-level assignment and comparison.  A handle to the desired context is
passed as an argument in the \Cstd \CTYPE{shmem\_ctx\_*} and type-generic API
routines.  API routines that do not accept a context argument operate on the
default context.  The default context can be used explicitly through the
\CONST{SHMEM\_CTX\_DEFAULT} handle.

\subsubsection{\textbf{SHMEM\_CTX\_CREATE}}
\label{subsec:shmem_ctx_create}
\apisummary{
    Create a communication context.
}

\begin{apidefinition}

\begin{Csynopsis}
int shmem_ctx_create(long options, shmem_ctx_t *ctx);
\end{Csynopsis}

\begin{apiarguments}
    \apiargument{IN}{options}{The set of options requested for the given context.
        Multiple options may be requested by combining them with a bitwise
        OR operation.  Otherwise, \CONST{0} can be given if no options are
        requested.}
    \apiargument{OUT}{ctx}{A handle to the newly created context.}
\end{apiarguments}

\apidescription{
    The \FUNC{shmem\_ctx\_create} routine creates a new communication context
    and returns its handle through the \VAR{ctx} argument.  If the context was
    created successfully, a value of zero is returned; otherwise a nonzero
    value is returned.  An unsuccessful context
    creation call is not treated as an error and the \openshmem library remains
    in a correct state.  The creation call can be reattempted with different
    options or after additional resources become available.

    By default contexts are {\em shareable} and, when it is allowed by the
    threading model set during initialization, they can be used concurrently by
    multiple threads within the PE where they were created.
    %
    The following options can be supplied during context creation to restrict
    this usage model and enable performance optimizations.  When using a given
    context, the application must comply with the requirements of all options
    set on that context.  Otherwise the behavior is undefined.

        \apitablerow{\CONST{SHMEM\_CTX\_SERIALIZED}}{
            The given context is shareable; however, it will not be used by multiple threads
            concurrently.  When the \CONST{SHMEM\_CTX\_SERIALIZED} option is
            set, the user must ensure that operations involving the given
            context are serialized by the application.}

        \apitablerow{\CONST{SHMEM\_CTX\_PRIVATE}}{
            The given context will be used only by the thread that created it.}
}

\apireturnvalues{
    Zero on success and nonzero otherwise.
}

\apinotes{
    None.
}

\end{apidefinition}

\subsubsection{\textbf{SHMEM\_CTX\_DESTROY}}
\label{subsec:shmem_ctx_create}
\apisummary{
    Destroy a communication context.
}

\begin{apidefinition}

\begin{Csynopsis}
void shmem_ctx_destroy(shmem_ctx_t ctx);
\end{Csynopsis}

\begin{apiarguments}
    \apiargument{IN}{ctx}{Handle to the context that will be destroyed.}
\end{apiarguments}

\apidescription{
    \FUNC{shmem\_ctx\_destroy} destroys a context that was created by a call to
    \FUNC{shmem\_ctx\_create}.  It is the user's responsibility to ensure that
    the context is not used after it has been destroyed, for example when the
    destroyed context is used by multiple threads.  This function
    performs an implicit quiet operation on the given context before it is freed.
}

\apireturnvalues{
    None.
}

\apinotes{
    Destroying a context makes it impossible for the user to complete
    communication operations that are pending on that context.  This includes
    nonblocking communication operations, whose local buffers are only returned
    to the user after the operations have been completed.  An implicit quiet is
    performed when freeing a context to avoid this ambiguity.

    A context with the \CONST{SHMEM\_CTX\_PRIVATE} option enabled must be
    destroyed by the thread that created it.

    \textcolor{red}{OPTION A1: The \CONST{SHMEM\_CTX\_DEFAULT} context may
    be destroyed by a call to \FUNC{shmem\_ctx\_destroy}, but communication
    operations may no longer complete on the default context.}

    \textcolor{red}{OPTION A2: The \CONST{SHMEM\_CTX\_DEFAULT} context will
    \textit{not} be destroyed by a call to \FUNC{shmem\_ctx\_destroy}.
    Typically, a call to \FUNC{shmem\_finalize} releases resources associated
    with the default context}.

    \textcolor{red}{All other shareable contexts must be destroyed explicitly
    with a call to \FUNC{shmem\_ctx\_destroy} by (some?, any?, all?) thread(s) within the PE that
    called \FUNC{shmem\_ctx\_create}}.

}

\begin{apiexamples}

    \apicexample
    {The following example demonstrates the use of contexts in a multithreaded
    \Cstd program that uses OpenMP for threading.  This example shows the
    shared counter load balancing method and illustrates the use of contexts
    for thread isolation.}
    {./example_code/shmem_ctx.c}
    {}

    \apicexample
    {The following example demonstrates the use of contexts in a
    single-threaded \Cstd program that performs a summation reduction where
    the data contained in the \VAR{in\_buf} arrays on all PEs is reduced into
    the \VAR{out\_buf} arrays on all PEs.  The buffers are divided into
    segments and processing of the segments is pipelined.  Contexts are used
    to overlap an all-to-all exchange of data for segment \VAR{p} with the
    local reduction of segment \VAR{p-1}.}
    {./example_code/shmem_ctx_pipelined_reduce.c}
    {}

\end{apiexamples}

\textcolor{red}{Why no call to \FUNC{shmem\_ctx\_destroy} in the pipeline example?  Is
it ok to assume all shared contexts are destroyed in finalize?}

\end{apidefinition}
\color{black}
