\apisummary{
    Stop a communication session.
}

\begin{apidefinition}

\begin{Csynopsis}
void @\FuncDecl{shmem\_ctx\_session\_stop}@(shmem_ctx_t ctx);
\end{Csynopsis}

\begin{apiarguments}
    \apiargument{IN}{ctx}{A context handle specifying the context associated
    with this session.}
\end{apiarguments}

\apidescription{
    The \FUNC{shmem\_ctx\_session\_stop} routine ends a session on context \VAR{ctx}.
    If a session is already stopped on a given communication context, another
    call to \FUNC{shmem\_ctx\_session\_stop} on that context has no effect.
}

\apireturnvalues{
    None.
}

\apinotes{
    Users are discouraged from including non-\openshmem code, such as a long
    computation loop, within a session without first calling
    \FUNC{shmem\_ctx\_session\_stop}.
}


\begin{apiexamples}

\apicexample
    {The following \CorCpp{} program demonstrates the usage of
    \FUNC{shmem\_ctx\_session\_start} and \FUNC{shmem\_ctx\_session\_stop} with a loop of
    random atomic non-fetching XOR updates to a distributed table, similar to
    the HPC Challenge RandomAccess GUPS (Giga-updates per second) benchmark
    \footnote{http://icl.cs.utk.edu/projectsfiles/hpcc/RandomAccess/}.}
    {./example_code/shmem_ctx_session_example.c}
    {}
\end{apiexamples}

\end{apidefinition}

